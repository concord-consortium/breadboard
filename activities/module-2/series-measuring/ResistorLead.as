package {        import flash.display.DisplayObject;    import flash.display.MovieClip;    import flash.events.MouseEvent;    import flash.geom.ColorTransform;    import flash.geom.Point;    import flash.geom.Rectangle;        import org.concord.sparks.JavaScript;    import org.concord.sparks.util.Display;        /*      * Represents a lead of the resistor.     * A resistor has two leads: left and right.     */    public class ResistorLead {                public static const ORIGINAL:int = 0;        public static const ROLL_OVER:int = 1;        public static const ENGAGED:int = 2;                protected var id:String;        protected var lead:DisplayObject;				private var resistorBase:ResistorBase;		private var resistor:String;		private var side:String;            private var rollover:DisplayObject; //highlighted are to be shown when mouse is over the lead        private var engaged:DisplayObject; //to be shown when the lead is connected to another component        private var brokenLead:DisplayObject;            private var state:int = ORIGINAL;        private var brokenState:int = ORIGINAL;        private var broken:Boolean = false;        private var location:String; //coordinate on breadboard, e.g. c21            private var rolloverColor:ColorTransform = new ColorTransform();        private var engagedColor:ColorTransform = new ColorTransform();        private var originalColor:ColorTransform = new ColorTransform();                private var breakButton:DisplayObject;        private var restoreButton:DisplayObject;				private var probe:Probe;		private var probeShiftX:Number;		private var probeShiftY:Number;            public function ResistorLead(base:ResistorBase, id:String, lead:DisplayObject,            rollover:DisplayObject, engaged:DisplayObject, brokenLead:DisplayObject,            rolloverColor:ColorTransform, engagedColor:ColorTransform, originalColor:ColorTransform,            breakButton:DisplayObject, restoreButton:DisplayObject) {			            //trace('ENTER ResistorLead#ResistorLead');			this.resistorBase = base;            this.id = id;            this.lead = lead;            this.rollover = rollover;            this.engaged = engaged;            this.brokenLead = brokenLead;                        this.rolloverColor = rolloverColor;            this.engagedColor = engagedColor;            this.originalColor = originalColor;                        this.breakButton = breakButton;            this.restoreButton = restoreButton;            rollover.visible = false;            engaged.visible = false;            brokenLead.visible = false;			lead.visible = true;                        restoreButton.visible = false;			breakButton.visible = true;                        breakButton.addEventListener(MouseEvent.MOUSE_UP, onBreak);        }        		public function setProbe(newProbe:Probe):void {			this.probe = newProbe;			trace('SET PROBE TO '+this.probe);		}		public function getProbe():Probe {			return this.probe;		}				public function calcProbeShift():void {			if(probe!=null){				var probeTip:Point = new Point(probe.x, probe.y);				var leadRegPoint:Point = new Point(lead.x, lead.y);				leadRegPoint = lead.parent.localToGlobal(leadRegPoint); // converts lead's registration point to global coords (I think that the global is not stage coords but breadboard coords - but it's not important because calculations are relative)				probeTip = probe.parent.localToGlobal(probeTip); // convert's probe's registration point to global coords  (as a note, this also works - lead.parent.parent.parent.localToGlobal(probeTip) )							//the geometry is for connecting to the lead in the down position, but it is close enough to use the same calculations for connecting to the lead in the up position - (or possibly the geometry is the same if it's calculated locally on the lead so that the transform is not important)				var angle:Number = .576; // 33 degrees in Radians				var hyp:Number = Math.abs(probeTip.x - leadRegPoint.x);//hypotenuse				probeShiftY = hyp*Math.sin(angle);				probeShiftX = Math.abs(probeTip.x - leadRegPoint.x) - hyp*Math.cos(angle);			}		}				public function setResistor(res:String):void {			this.resistor = res;		}				public function setSide(side:String):void {			this.side = side;		}		public function getSide():String {			return this.side;		}		        public function getId():String {            return id;        }                public function isBroken():Boolean {            return broken;        }                public function getLocation():String {            return location;        }                public function setLocation(loc:String):void {            location = loc;        }                public function getState():int {            return state;        }                public function getBrokenState():int {            return brokenState;        }                public function showRollOver():void {            rollover.visible = true;        }        public function hideRollOver():void {            rollover.visible = false;        }                public function showEngaged():void {			engaged.visible = true;            engaged.alpha = 0.55;        }        public function hideEngaged():void {            trace('ENTER ResistorLead.hideEngaged');            engaged.visible = false;        }                public function setRollOver():void {            //trace('ENTER ResistorLead#setRollOver');            state = ROLL_OVER;			lead.visible = true;            lead.transform.colorTransform = rolloverColor;			brokenLead.transform.colorTransform = rolloverColor;			brokenLead.visible = false;        }                public function setEngaged():void {            //trace('ENTER ResistorLead#setEngaged');            state = ENGAGED;			lead.visible = true;            lead.transform.colorTransform = engagedColor;			brokenLead.transform.colorTransform = engagedColor;			brokenLead.visible = false;        }                public function setOriginal():void {            //trace('ENTER ResistorLead#setOriginal');            state = ORIGINAL;			lead.visible = true;            lead.transform.colorTransform = originalColor;			brokenLead.transform.colorTransform = originalColor;			brokenLead.visible = false;        }        public function setBrokenRollOver():void {            //trace('ENTER ResistorLead#setBrokenRollOver');            brokenState = ROLL_OVER;			brokenLead.visible = true;            brokenLead.transform.colorTransform = rolloverColor;			lead.transform.colorTransform = rolloverColor;			lead.visible = false;        }                public function setBrokenEngaged():void {            //trace('ENTER ResistorLead#setBrokenEngaged');            brokenState = ENGAGED;			brokenLead.visible = true;            brokenLead.transform.colorTransform = engagedColor;			lead.transform.colorTransform = originalColor;			lead.visible = false;        }                public function setBrokenOriginal():void {            //trace('ENTER ResistorLead#setBrokenOriginal');            brokenState = ORIGINAL;			brokenLead.visible = true;            brokenLead.transform.colorTransform = originalColor;			lead.transform.colorTransform = originalColor;			lead.visible = false;        }                private function onBreak(event:MouseEvent):void {            broken = true;			breakButton.visible = false;            restoreButton.visible = true;            restoreButton.addEventListener(MouseEvent.MOUSE_UP, onRestore);			breakButton.removeEventListener(MouseEvent.MOUSE_UP, onBreak);            lead.visible = false;			brokenLead.visible = true;						// lift probe			if(probe !=null){				probe.y -= probeShiftY;				if(this.side == 'left'){					probe.x += probeShiftX;				} else if (this.side == 'right') {					probe.x -= probeShiftX;				}			probe.getCircuit().updateResistorEndColors(probe);			probe.getCircuit().updateProbeConnection(probe);			}			resistorBase.disconnect(this); //jonah        }                private function onRestore(event:MouseEvent):void {            broken = false;            breakButton.visible= true;            restoreButton.visible= false;            restoreButton.removeEventListener(MouseEvent.MOUSE_UP, onRestore);			breakButton.addEventListener(MouseEvent.MOUSE_UP, onBreak);            lead.visible = true;			brokenLead.visible = false;			resistorBase.connect(this); //jonah			// lower probe			if(probe !=null){				probe.y += probeShiftY;				if(this.side == 'left'){					probe.x -= probeShiftX;				} else if (this.side == 'right') {					probe.x += probeShiftX;				}				probe.getCircuit().updateResistorEndColors(probe);				probe.getCircuit().updateProbeConnection(probe);			}        }				private function resistorConnect():void {            JavaScript.instance().sendEvent('connect', 'resistor', this.resistor, this.side, location);        }				private function resistorDisconnect():void {            JavaScript.instance().sendEvent('disconnect', 'resistor', this.resistor, this.side, location);        }        public function inBrokenHotSpot(probe:Probe):Boolean {           //return  brokenLead.alpha == 1 && probe.tip.hitTestObject(brokenLead);		   return  brokenLead.visible == true && probe.tip.hitTestObject(brokenLead);        }    }}