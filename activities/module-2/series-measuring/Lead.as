package{	import flash.display.MovieClip;	import flash.display.Shape;	import flash.display.Graphics;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.CapsStyle;	import flash.display.Sprite;	 	import flash.events.MouseEvent;    import flash.geom.ColorTransform;    import flash.geom.Point;    import flash.geom.Rectangle;        import org.concord.sparks.JavaScript;    import org.concord.sparks.util.Display;		public class Lead extends ComponentObj{			        public static const ORIGINAL:int = 0;        public static const ROLL_OVER:int = 1;        public static const ENGAGED:int = 2;                protected var id:String;        public var lead:DisplayObjectContainer; //should be protected				private var componentObj:ComponentResistor;		private var componentName:String;		private var side:String;            private var rollover:DisplayObjectContainer; //highlighted area to be shown when mouse is over the lead        private var engaged:DisplayObjectContainer; //to be shown when the lead is connected to another component        public var brokenLead:DisplayObjectContainer; //should be private		        private var state:int = ORIGINAL;        private var brokenState:int = ORIGINAL;        private var broken:Boolean = false;        private var location:String; //coordinate on breadboard, e.g. c21            private var rolloverColor:ColorTransform = new ColorTransform();        private var engagedColor:ColorTransform = new ColorTransform();        private var originalColor:ColorTransform = new ColorTransform();                private var breakButton:DisplayObject;        private var restoreButton:DisplayObject;				private var probe:Probe;		private var probeShiftX:Number;		private var probeShiftY:Number;								public function Lead() {			trace('ENTER Lead');						super();									this.lead = this.getChildByName('normal_mc') as DisplayObjectContainer;            this.brokenLead = this.getChildByName('broken_mc') as DisplayObjectContainer;            			this.rolloverColor.redOffset = 0;            this.rolloverColor.greenOffset = 0;            this.rolloverColor.blueOffset = 255;            this.engagedColor.redOffset = 80;            this.engagedColor.greenOffset = 60;            this.engagedColor.blueOffset = 0;                        this.originalColor.redOffset = 0;            this.originalColor.greenOffset = 0;            this.originalColor.blueOffset = 0;                        this.breakButton = this.getChildByName('break_btn');            this.restoreButton = this.getChildByName('restore_btn');            brokenLead.visible = false;			lead.visible = true;                        restoreButton.visible = false;			breakButton.visible = true;                        breakButton.addEventListener(MouseEvent.MOUSE_UP, onBreak);		}				public function setProbe(newProbe:Probe):void {			this.probe = newProbe;			trace('SET PROBE TO '+this.probe);		}		public function getProbe():Probe {			return this.probe;		}		public function getLeadMovieClip():DisplayObjectContainer {			return this.lead;		}		public function setComponentObj(componentObj:ComponentResistor):void {			this.componentObj = componentObj;		}		public function getComponentObj():ComponentResistor { //added for debugging, can erase			return this.componentObj;		}		public function setComponentName(componentName:String):void {			this.componentName = componentName;			this.id = componentName;		}		public function getComponentName():String { //added for debugging, can erase			return this.componentName;		}		public function getProbeShiftX():Number { //added for debugging, can erase			return this.probeShiftX;		}				public function calcProbeShift():void {			if(probe!=null){				var probeTip:Point = new Point(probe.x, probe.y);				var leadRegPoint:Point = new Point(lead.x, lead.y);				leadRegPoint = lead.parent.localToGlobal(leadRegPoint); // converts lead's registration point to global coords (I think that the global is not stage coords but breadboard coords - but it's not important because calculations are relative)				probeTip = probe.parent.localToGlobal(probeTip); // convert's probe's registration point to global coords  (as a note, this also works - lead.parent.parent.parent.localToGlobal(probeTip) )							//the geometry is for connecting to the lead in the down position, but it is close enough to use the same calculations for connecting to the lead in the up position - (or possibly the geometry is the same if it's calculated locally on the lead so that the transform is not important)				var angle:Number = .576; // 33 degrees in Radians				var hyp:Number = Math.abs(probeTip.x - leadRegPoint.x);//hypotenuse				probeShiftY = hyp*Math.sin(angle);				probeShiftX = Math.abs(probeTip.x - leadRegPoint.x) - hyp*Math.cos(angle);			}		}		        public function getId():String {            return id;        }                public function isBroken():Boolean {            return broken;        }                public function getLocation():String {            return location;        }                public function setLocation(loc:String):void {            location = loc;        }                public function getState():int {            return state;        }                public function getBrokenState():int {            return brokenState;        }                        public function setRollOver():void {            //trace('ENTER ResistorLead#setRollOver');            state = ROLL_OVER;			brokenState = ORIGINAL;			lead.visible = true;            lead.transform.colorTransform = rolloverColor;			brokenLead.transform.colorTransform = rolloverColor;			brokenLead.visible = false;        }                public function setEngaged():void {            //trace('ENTER ResistorLead#setEngaged');            state = ENGAGED;			brokenState = ORIGINAL;			lead.visible = true;            lead.transform.colorTransform = engagedColor;			brokenLead.transform.colorTransform = engagedColor;			brokenLead.visible = false;        }                public function setOriginal():void {            //trace('ENTER ResistorLead#setOriginal');            state = ORIGINAL;			brokenState = ORIGINAL;			lead.visible = true;            lead.transform.colorTransform = originalColor;			brokenLead.transform.colorTransform = originalColor;			brokenLead.visible = false;        }        public function setBrokenRollOver():void {            //trace('ENTER ResistorLead#setBrokenRollOver');            brokenState = ROLL_OVER;			brokenLead.visible = true;            brokenLead.transform.colorTransform = rolloverColor;			lead.transform.colorTransform = rolloverColor;			lead.visible = false;			state = ORIGINAL;        }                public function setBrokenEngaged():void {            //trace('ENTER ResistorLead#setBrokenEngaged');            brokenState = ENGAGED;			brokenLead.visible = true;            brokenLead.transform.colorTransform = engagedColor;			lead.transform.colorTransform = originalColor;			lead.visible = false;			state = ORIGINAL;        }                public function setBrokenOriginal():void {            //trace('ENTER ResistorLead#setBrokenOriginal');            brokenState = ORIGINAL;			brokenLead.visible = true;            brokenLead.transform.colorTransform = originalColor;			lead.transform.colorTransform = originalColor;			lead.visible = false;			state = ORIGINAL;        }                private function onBreak(event:MouseEvent):void {			//check broken state and set accordingly  <--------------!!!!!!!!!!!!!!            broken = true;			breakButton.visible = false;            restoreButton.visible = true;            restoreButton.addEventListener(MouseEvent.MOUSE_UP, onRestore);			breakButton.removeEventListener(MouseEvent.MOUSE_UP, onBreak);            lead.visible = false;			brokenLead.visible = true;			componentObj.disconnect(this); //jonah						// lift probe			if(probe !=null){				probe.y -= probeShiftY;				probe.x -= -1 * this.scaleX / Math.abs(this.scaleX) * probeShiftX; //shift the probe in the opposite direction of the lead, if the lead is backwards, shift forwards			}        }                private function onRestore(event:MouseEvent):void {            broken = false;            breakButton.visible= true;            restoreButton.visible= false;            restoreButton.removeEventListener(MouseEvent.MOUSE_UP, onRestore);			breakButton.addEventListener(MouseEvent.MOUSE_UP, onBreak);            lead.visible = true;			brokenLead.visible = false;			componentObj.connect(this); //jonah			// lower probe			if(probe !=null){				probe.y += probeShiftY;				probe.x += -1 * this.scaleX / Math.abs(this.scaleX) * probeShiftX; //shift the probe in the opposite direction of the lead, if the lead is backwards, shift forwards			}        }        public function inHotSpot(probe:Probe):Boolean {            //trace('ENTER Lead#inHotSpot id=' + id);			return probe.tip.hitTestObject(lead.getChildByName('hitArea_mc'));        }        public function inBrokenHotSpot(probe:Probe):Boolean {			//trace('ENTER Lead#inBrokenHotSpot id='+ id);		  	return  brokenLead.visible == true && probe.tip.hitTestObject(brokenLead.getChildByName('hitArea_mc'));        }    }}