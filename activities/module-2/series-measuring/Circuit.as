package {    import flash.display.MovieClip;	import flash.display.DisplayObjectContainer;	import flash.display.*;    import flash.geom.Point;    import flash.media.Sound;    import flash.media.SoundChannel;    import flash.media.SoundTransform;		import flash.events.MouseEvent; // for debugging, can erase		import flash.display.Shape;        import org.concord.sparks.JavaScript;    import org.concord.sparks.circuit.multimeter.dmm_centech.DmmCentech2;	import Resistor4Band;	import Resistor5Band;	import Breadboard;	import ComponentWire;    public class Circuit {        private var activity;        private var root;        private var breadboard:MovieClip;        private var multimeter:DmmCentech2;		private var redProbe:Probe;        private var blackProbe:Probe;        private var resistors:Array = new Array();		private var wires:Array = new Array();                private var sndClickIt:clickit3;        private var sndClickItChannel:SoundChannel;        private var transform1:SoundTransform=new SoundTransform();				private var breadboardMC:ComponentBreadboard;        public function Circuit(activity, root) {            this.activity = activity;            this.root = root;            breadboard = root.outer_breadboard_mc.breadboard_mc;			multimeter = root.dmm_mc;			            redProbe = breadboard.probe_red;            redProbe.setCircuit(this);            blackProbe = breadboard.probe_black;            blackProbe.setCircuit(this);                        multimeter.setDisplayText('  9.0 0');						breadboardMC = root.outer_breadboard_mc;			breadboardMC.expandOnFocus.setStartX(breadboardMC.x);			breadboardMC.expandOnFocus.setStartY(breadboardMC.y);						redProbe.visible=false;			blackProbe.visible=false;			multimeter.visible=false;						breadboard.stage.addEventListener(MouseEvent.MOUSE_DOWN,traceStatus);        }		public function traceStatus(Event:MouseEvent):void {			trace('redProbe');			trace('connection '+redProbe.getConnection());			trace('circuit '+redProbe.getCircuit());			trace('id '+redProbe.getId());			trace('_dragging '+redProbe._dragging);			trace('_down '+redProbe.getIfDown());			trace();			trace('blackProbe');			trace('connection '+blackProbe.getConnection());			trace('circuit '+blackProbe.getCircuit());			trace('id '+blackProbe.getId());			trace('_dragging '+blackProbe._dragging);			trace('_down '+blackProbe.getIfDown());			trace();			trace('lead1');			trace('resistor[0] '+resistors[0].getEnds()[0]);			trace('componentObj '+resistors[0].getEnds()[0].getComponentObj());			trace('componentName '+resistors[0].getEnds()[0].getComponentName());			trace('probe '+resistors[0].getEnds()[0].getProbe());			trace('probeShiftX '+resistors[0].getEnds()[0].getProbeShiftX());			trace('side ');			trace('location '+resistors[0].getEnds()[0].getLocation());			trace('getState '+resistors[0].getEnds()[0].getState());			trace('getBrokenState '+resistors[0].getEnds()[0].getBrokenState());			trace('lead.visible '+resistors[0].getEnds()[0].lead.visible);			trace('brokenLead.visible '+resistors[0].getEnds()[0].brokenLead.visible);			trace();			trace('lead2');			trace('resistor[0] '+resistors[0].getEnds()[1]);			trace('componentObj '+resistors[0].getEnds()[1].getComponentObj());			trace('componentName '+resistors[0].getEnds()[1].getComponentName());			trace('probe '+resistors[0].getEnds()[1].getProbe());			trace('probeShiftX '+resistors[0].getEnds()[1].getProbeShiftX());			trace('side ');			trace('location '+resistors[0].getEnds()[1].getLocation());			trace('getState '+resistors[0].getEnds()[1].getState());			trace('getBrokenState '+resistors[0].getEnds()[1].getBrokenState());			trace('lead.visible '+resistors[0].getEnds()[1].lead.visible);			trace('brokenLead.visible '+resistors[0].getEnds()[1].brokenLead.visible);			trace();			trace('leadLeft '+resistors[0].getEnds()[0]);			trace('leadRight '+resistors[0].getEnds()[1]);		}		//>>> sparks.flash.sendCommand('insert_component','resistor','resistor1','a29,b17','4band','label-text','green,blue,blue,red,red');		public function insertComponent(componentKind:String, componentName:String, position:String, ...values):String {			switch(componentKind) {				case 'resistor':					//...values					var type:String = values[0];					var tempArr:Array = values[1].toString().split(",");					var componentLabel = tempArr.shift();					var colorsArr:Array =tempArr;										var i:int = resistors.length;  // get length for new resistor array					if(type == '4band') {						resistors[i] = new resistorFourBand_mc;						resistors[i].setColorBands(colorsArr);						resistors[i].setLabel(componentLabel);					} else if(type == '5band') {						resistors[i] = new resistorFiveBand_mc;						resistors[i].setColorBands(colorsArr);						resistors[i].setLabel(componentLabel);					} else if(type == 'wire') { // wires are a temporary fix to work until the regular wires can be built to accept probes and disconnect						resistors[i] = new wireSpecial_mc;					}					//resistors[i].setColorBands(colorsArr); //temporarily moved into resistor type for wireSpecial to work					positionComponent(componentKind, resistors[i], position);					resistors[i].name = componentName;					trace(resistors[i].name);					//breadboard.addChildAt(resistors[i],breadboard.numChildren);  // need to fix the level here to be the highest without being on top of probes					breadboard.getComponentLayer().addChild(resistors[i]);					breadboard.sortZindexByVerticalPosition(breadboard.getComponentLayer());				break;				case 'multimeter':				break;				case 'battery':				break;				case 'wire':					var wireColor:String = values[0];					var newWire:int = wires.length;					wires.push(new ComponentWire(breadboard));					wires[newWire].name = componentName;					positionComponent(componentKind, wires[newWire], position);					wires[newWire].setColor(wireColor);					breadboard.sortZindexByVerticalPosition(breadboard.getComponentLayer());				break;			}			return '';		}		private function parseCoordinates(coordinateStr:String):Array { //takes a string of two coordinates and outputs in a two dimensional array with row/hole count, such that [0][0] = x1, [0][1] = y1, [1][0] = x2, [1][1] = y2			var tempCoordinates:Array = coordinateStr.split(",");  // 'a6,a12' -> ['a6','a12']			var coordinatesArr:Array = new Array();			for(var i:int = 0; i<2; i++){				var coordinate:String = tempCoordinates[i];								// left positive power rail				if(coordinate.indexOf('left_positive') != -1 ){					trace('coordinate '+coordinate);					coordinatesArr[i] = new Array('pos1',coordinate.substring(13,coordinate.length)); //for each element: 'left_positive6' -> [pos1][6]					trace('coordinate '+coordinatesArr[i]);								// right positive power rail				} else if(coordinate.indexOf('right_positive') != -1 ) {					coordinatesArr[i] = new Array('pos2',coordinate.substring(14,coordinate.length)); //for each element: 'right_positive6' -> [pos2][6]					trace('coordinate '+coordinatesArr[i]);								// left negative power rail				} else if(coordinate.indexOf('left_negative') != -1 ) {					coordinatesArr[i] = new Array('neg1',coordinate.substring(13,coordinate.length)); //for each element: 'left_negative6' -> [neg1][6]								// right negative power rail				} else if(coordinate.indexOf('right_negative') != -1 ) {					coordinatesArr[i] = new Array('neg2',coordinate.substring(14,coordinate.length)); //for each element: 'right_negative6' -> [neg2][6]								// main board				} else {					coordinatesArr[i] = new Array(coordinate.substring(0,1),coordinate.substring(1,coordinate.length)); //for each element: 'a6' -> [a][6]					var rowLabels:Array = new Array("a","b","c","d","e","f","g","h","i","j"); //,"k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"					coordinatesArr[i][0] = rowLabels.indexOf(coordinatesArr[i][0])+1; //convert row letter to row number, 'a' = 1, 'b' = 2, etc.    [a][6] -> [1][6]				}			}			return coordinatesArr;		}				private function positionComponent(componentKind:String, componentObj:MovieClip, position:String) {  //  ( 'resistor', [object] , 'a6,b12' )			var xPos:Number;			var yPos:Number;			var x2Pos:Number;			var y2Pos:Number;			var coordinates:Array;			var holeNum:int;			var rowNum:int;			var hole2Num:int;			var row2Num:int;			switch(componentKind) {				case 'resistor':					coordinates = parseCoordinates(position); // string 'a6,b12' -> 2d array [0][0] = 1, [0][1] = 6, [1][0] = 2, [1][1] = 12					holeNum = coordinates[0][1];					rowNum = coordinates[0][0];					xPos = breadboard.getRows()[rowNum][holeNum].x + breadboard.holeSize/2;					yPos = breadboard.getRows()[rowNum][holeNum].y + breadboard.holeSize/2;					componentObj.x = xPos;					componentObj.y = yPos;				break;								case 'wire':					coordinates = parseCoordinates(position); // string 'a6,b12' -> 2d array [0][0] = 1, [0][1] = 6, [1][0] = 2, [1][1] = 12					//trace('coordinates '+coordinates);					var boardSection:Array = new Array();					var getRows:Array = new Array();					var numOfPowerHoles:int = 25;										for(var i:int=0; i<2; i++){						if(String(coordinates[i][0]).indexOf('pos') != -1) {							boardSection[i] = 'pos';							if(String(coordinates[i][0]) == 'pos1') {								coordinates[i][0] = 1;							} else {								coordinates[i][0] = 2;							}							coordinates[i][1] = numOfPowerHoles +1 - coordinates[i][1]; // switch counting from right to left (like labels on breadboard) to left to right (like breadboard.as)						} else if(String(coordinates[i][0]).indexOf('neg') != -1) {							if(String(coordinates[i][0]) == 'neg1') {								coordinates[i][0] = 1;							} else {								coordinates[i][0] = 2;							}							boardSection[i] = 'neg';							coordinates[i][1] = numOfPowerHoles +1 - coordinates[i][1]; // switch counting from right to left (like labels on breadboard) to left to right (like breadboard.as)						} else {							boardSection[i] = 'main';						}						if(i==0){							holeNum = coordinates[0][1];							rowNum = coordinates[0][0];							//trace('row#  coordinates[0][0] '+coordinates[0][0]);							//trace('hole# coordinates[0][1] '+coordinates[0][1]);													}						if(i==1){							hole2Num = coordinates[1][1];							row2Num = coordinates[1][0];							//trace('row#  coordinates[1][0] '+coordinates[1][0]);							//trace('hole# coordinates[1][1] '+coordinates[1][1]);													}						switch(boardSection[i]) {							case 'pos':								if(i==0){									xPos = breadboard.getPosRows()[rowNum][holeNum].x + breadboard.holeSize/2;									yPos = breadboard.getPosRows()[rowNum][holeNum].y + breadboard.holeSize/2;								}								if(i==1){									x2Pos = breadboard.getPosRows()[row2Num][hole2Num].x + breadboard.holeSize/2;									y2Pos = breadboard.getPosRows()[row2Num][hole2Num].y + breadboard.holeSize/2;								}							break;								case 'neg':								if(i==0){									xPos = breadboard.getNegRows()[rowNum][holeNum].x + breadboard.holeSize/2;									yPos = breadboard.getNegRows()[rowNum][holeNum].y + breadboard.holeSize/2;								}								if(i==1){									x2Pos = breadboard.getNegRows()[row2Num][hole2Num].x + breadboard.holeSize/2;									y2Pos = breadboard.getNegRows()[row2Num][hole2Num].y + breadboard.holeSize/2;								}							break;							case 'main':												trace('main');								if(i==0){									xPos = breadboard.getRows()[rowNum][holeNum].x + breadboard.holeSize/2;									yPos = breadboard.getRows()[rowNum][holeNum].y + breadboard.holeSize/2;								}								if(i==1){									x2Pos = breadboard.getRows()[row2Num][hole2Num].x + breadboard.holeSize/2;									y2Pos = breadboard.getRows()[row2Num][hole2Num].y + breadboard.holeSize/2;								}							break;						}					}					componentObj.x = xPos;					componentObj.y = yPos;					componentObj.dimension(0,0, x2Pos-xPos, y2Pos-yPos);				break;								case 'multimeter':				break;				case 'battery':				break;			}		}										           public function getResistor(id:String) {            return breadboard[id];        }                public function getMultimeter():DmmCentech2 {            return multimeter;        }				public function getBlackProbe():Probe {			return blackProbe;		}		public function getRedProbe():Probe {			return redProbe;		}				public function getProbeVisibility():Boolean {			return blackProbe.visible; // red probe should be the same		}		//visibility can be set from the javascript as follows:		//flash.sendCommand('set_probe_visiblity','true');		//		//or in flash with		//circuit.blackProbe.setVisibility('true');		//circuit.redProbe.setVisibility('true');				public function setProbeVisibility(statStr:String) {			switch((statStr).toLowerCase()) { 		    	case "true":				case "1":				case "yes":				default:				this.blackProbe.visible = true;				this.redProbe.visible = true;				break;				case "false":				case "0":				case "no":				this.blackProbe.visible = false;				this.redProbe.visible = false;			}		}        public function updateProbeConnection(probe:Probe):void {            trace('ENTER Circuit#updateProbeConnection');            var oldConnection:Object = probe.getConnection();            var connection:Object = null;            var ends;                        for (var i = 0; i < resistors.length; ++i) {                ends = resistors[i].getEnds();                for (var j = 0; j < 2; ++j) {                    if (ends[j].isBroken()) {                        if (ends[j].inBrokenHotSpot(probe)) {//(ends[j].inBrokenHotSpot(probe)) {                            connection = ends[j];                            ends[j].setBrokenEngaged();							//ends[j].calcProbeShift();                        }                    }                    else {						trace('probe tip '+probe.tip.parent.x);                        if (ends[j].inHotSpot(probe)) {//(ends[j].inHotSpot(probe)) {                            connection = ends[j];                            ends[j].setEngaged();							//ends[j].calcProbeShift();                        } else { //added by jonah							connection = null;						}                    }                }            }                        if (connection !== oldConnection) {                clickSound();				trace('connection '+connection);                probe.setConnection(connection);				trace();				trace();				trace('new connection!!!');				trace();				JavaScript.instance().sendEvent('connect', 'probe', probe.getId(), connection.getLocation());				if(connection !=null){					connection.calcProbeShift();				} else {					/*trace('washss');					probe.setConnection(connection);					probe.disConnect();//disconnect probe					trace('!!!!!!disconnect '+oldConnection.parent +oldConnection);*/				}			}        }        public function setProbeConnection(probe:Probe):void {  //same as update probe connection, but with a smaller hit area (to ensure that the probe doesn't fall out of the hit area when a component's leads are lifted and lowered)            trace('ENTER Circuit#updateProbeConnection');            var oldConnection:Object = probe.getConnection();            var connection:Object = null;            var ends;                        for (var i = 0; i < resistors.length; ++i) {                ends = resistors[i].getEnds();                for (var j = 0; j < 2; ++j) {					trace('1');					ends[j].setProbe(null); //reset lead to not-connected view					trace('2');					ends[j].setBrokenOriginal(); //reset lead to default view					trace('3');					ends[j].setOriginal();  //reset lead to default view					trace('4');									trace('end '+j);                    if (ends[j].isBroken()) {						trace('end is broken');                        if (ends[j].inBrokenHotSpotSmall(probe)) {//(ends[j].inBrokenHotSpot(probe)) {							trace('end in broken hot spot');                            connection = ends[j];                            ends[j].setBrokenEngaged();							trace('setbrokenengaged');							ends[j].setProbe(probe);							//ends[j].calcProbeShift();                        } //else, set as disconnected                    }                    else {						trace('probe tip '+probe.tip.parent.x);                        if (ends[j].inHotSpotSmall(probe)) {//(ends[j].inHotSpot(probe)) {							trace('in hot spot');                            connection = ends[j];                            ends[j].setEngaged();							ends[j].setProbe(probe);							trace('set engaged ');							//ends[j].calcProbeShift();                        }                    }                }            }                        if (connection !== oldConnection) {                clickSound();				trace('connection '+connection);                probe.setConnection(connection);				JavaScript.instance().sendEvent('connect', 'probe', probe.getId(), connection.getLocation());                if(connection != null) {					trace();					trace('new connection!!!');					trace();					connection.calcProbeShift();									} else {					JavaScript.instance().sendEvent('disconnect', 'probe', probe.getId(), oldConnection.getLocation());					trace('connection null, reset rollover to none!');				}			}        }        public function updateResistorEndColors(probe:Probe):void {            //trace('ENTER Circuit#updateResistorEndColor');			            var ends;            for (var i = 0; i < resistors.length; ++i) {                ends = resistors[i].getEnds();                for (var j = 0; j < 2; ++j) {                    if (ends[j].isBroken()) {                        if (ends[j].inBrokenHotSpot(probe)) {							//if mouse down                            if (ends[j].getBrokenState() !== Lead.ROLL_OVER) {                                ends[j].setBrokenRollOver();								ends[j].setProbe(probe); //if connected, set probe							//if mouse up									                            }                        }                        else {                            if (!probeConnected(ends[j]) && ends[j].getBrokenState() !== Lead.ORIGINAL) {                                ends[j].setBrokenOriginal();                            }                        }                    }                    else {                        if (ends[j].inHotSpot(probe)) {                            if (ends[j].getState() !== Lead.ROLL_OVER) {                                ends[j].setRollOver();								ends[j].setProbe(probe); //if connected, set probe                            }                        }                        else {                            if (!probeConnected(ends[j]) && ends[j].getState() !== Lead.ORIGINAL) {                                ends[j].setOriginal();                            }                        }                    }                }            }        }        public function setResistorEndColors(probe:Probe):void {            //trace('ENTER Circuit#updateResistorEndColor');			            var ends;            for (var i = 0; i < resistors.length; ++i) {                ends = resistors[i].getEnds();                for (var j = 0; j < 2; ++j) {                    if (ends[j].isBroken()) {                        if (ends[j].inBrokenHotSpotSmall(probe)) {							//if mouse down                            if (ends[j].getBrokenState() !== Lead.ROLL_OVER) {                                ends[j].setBrokenRollOver();								ends[j].setProbe(probe); //if connected, set probe								//probe.setConnection(ends[j]);//set probe to resistor																                            }                        }                        else {                            if (!probeConnected(ends[j]) && ends[j].getBrokenState() !== Lead.ORIGINAL) {                                ends[j].setBrokenOriginal();								ends[j].setProbe(null); //set resistor to no-probe								//probe.setConnection(ends[j]);//set probe to null                            }                        }                    }                    else {                        if (ends[j].inHotSpotSmall(probe)) {                            if (ends[j].getState() !== Lead.ROLL_OVER) {                                ends[j].setRollOver();								ends[j].setProbe(probe); //if connected, set probe								//probe.setConnection(ends[j]);//set probe to resistor                            }                        }                        else {                            if (!probeConnected(ends[j]) && ends[j].getState() !== Lead.ORIGINAL) {                                ends[j].setOriginal();								ends[j].setProbe(null); //set resistor to no-probe								//probe.setConnection(ends[j]);//set probe to no resistor                            }                        }                    }                }            }        }        		public function putProbeOnTop(clickedProbe:Probe):void {			if(redProbe==clickedProbe) {				if(breadboard.getChildIndex(clickedProbe) < breadboard.getChildIndex(blackProbe)) {					breadboard.swapChildren(clickedProbe,blackProbe);				}			} else {				if(breadboard.getChildIndex(clickedProbe) < breadboard.getChildIndex(redProbe)) {					breadboard.swapChildren(clickedProbe,redProbe);				}			}		}		        private function probeConnected(end:Lead):Boolean {            return redProbe.getConnection() == end || blackProbe.getConnection() == end;        }        private function clickSound():void {            sndClickIt=new clickit3();            sndClickItChannel=sndClickIt.play();             transform1.volume=.75;            sndClickItChannel.soundTransform=transform1;        }	}}