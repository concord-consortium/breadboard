package {    import flash.display.MovieClip;	import flash.display.DisplayObjectContainer;	import flash.display.*;    import flash.geom.Point;    import flash.media.Sound;    import flash.media.SoundChannel;    import flash.media.SoundTransform;		import flash.events.MouseEvent; // for debugging, can erase		import flash.display.Shape;        import org.concord.sparks.JavaScript;    import org.concord.sparks.circuit.multimeter.dmm_centech.DmmCentech2;	import Resistor4Band;	import Resistor5Band;	import Breadboard;	import ComponentWire;    public class Circuit {        private var activity;        private var root;        private var breadboard:MovieClip;        private var multimeter:DmmCentech2;		private var redProbe:Probe;        private var blackProbe:Probe;        private var components:Array = new Array();		private var wires:Array = new Array();                private var sndClickIt:clickit3;        private var sndClickItChannel:SoundChannel;        private var transform1:SoundTransform=new SoundTransform();				private var breadboardMC:ComponentBreadboard;        public function Circuit(activity, root) {            this.activity = activity;            this.root = root;            breadboard = root.outer_breadboard_mc.breadboard_mc;			multimeter = root.dmm_mc;			            redProbe = breadboard.probe_red;            redProbe.setCircuit(this);            blackProbe = breadboard.probe_black;            blackProbe.setCircuit(this);                        multimeter.setDisplayText('  9.0 0');						breadboardMC = root.outer_breadboard_mc;			breadboardMC.expandOnFocus.setStartX(breadboardMC.x);			breadboardMC.expandOnFocus.setStartY(breadboardMC.y);						redProbe.visible=false;			blackProbe.visible=false;			multimeter.visible=false;        }		//>>> sparks.flash.sendCommand('insert_component','resistor','resistor1','a29,b17','4band','label-text','green,blue,blue,red,red');		public function insertComponent(componentKind:String, componentName:String, position:String, ...values):String {			switch(componentKind) {				case 'resistor':					//...values					var type:String = values[0];					var tempArr:Array = values[1].toString().split(",");					var componentLabel = tempArr.shift();					var colorsArr:Array =tempArr;										var i:int = components.length;  // get length for new resistor array					if(type == '4band') {						components[i] = new resistorFourBand_mc;						components[i].setColorBands(colorsArr);						components[i].setLabel(componentLabel);					} else if(type == '5band') {						components[i] = new resistorFiveBand_mc;						components[i].setColorBands(colorsArr);						components[i].setLabel(componentLabel);					} else if(type == 'wire') { // wires are a temporary fix to work until the regular wires can be built to accept probes and disconnect						components[i] = new wireSpecial_mc;					}					//components[i].setColorBands(colorsArr); //temporarily moved into resistor type for wireSpecial to work					positionComponent(componentKind, components[i], position);					components[i].name = componentName;					trace(components[i].name);					//breadboard.addChildAt(components[i],breadboard.numChildren);  // need to fix the level here to be the highest without being on top of probes					breadboard.getComponentLayer().addChild(components[i]);					breadboard.sortZindexByVerticalPosition(breadboard.getComponentLayer());				break;				case 'multimeter':				break;				case 'battery':				break;				case 'wire':					var wireColor:String = values[0];					var newWire:int = wires.length;					wires.push(new ComponentWire(breadboard));					wires[newWire].name = componentName;					positionComponent(componentKind, wires[newWire], position);					wires[newWire].setColor(wireColor);					breadboard.sortZindexByVerticalPosition(breadboard.getComponentLayer());				break;			}			return '';		}		private function parseCoordinates(coordinateStr:String):Array { //takes a string of two coordinates and outputs in a two dimensional array with row/hole count, such that [0][0] = x1, [0][1] = y1, [1][0] = x2, [1][1] = y2			var tempCoordinates:Array = coordinateStr.split(",");  // 'a6,a12' -> ['a6','a12']			var coordinatesArr:Array = new Array();			for(var i:int = 0; i<2; i++){				var coordinate:String = tempCoordinates[i];								// left positive power rail				if(coordinate.indexOf('left_positive') != -1 ){					trace('coordinate '+coordinate);					coordinatesArr[i] = new Array('pos1',coordinate.substring(13,coordinate.length)); //for each element: 'left_positive6' -> [pos1][6]					trace('coordinate '+coordinatesArr[i]);								// right positive power rail				} else if(coordinate.indexOf('right_positive') != -1 ) {					coordinatesArr[i] = new Array('pos2',coordinate.substring(14,coordinate.length)); //for each element: 'right_positive6' -> [pos2][6]					trace('coordinate '+coordinatesArr[i]);								// left negative power rail				} else if(coordinate.indexOf('left_negative') != -1 ) {					coordinatesArr[i] = new Array('neg1',coordinate.substring(13,coordinate.length)); //for each element: 'left_negative6' -> [neg1][6]								// right negative power rail				} else if(coordinate.indexOf('right_negative') != -1 ) {					coordinatesArr[i] = new Array('neg2',coordinate.substring(14,coordinate.length)); //for each element: 'right_negative6' -> [neg2][6]								// main board				} else {					coordinatesArr[i] = new Array(coordinate.substring(0,1),coordinate.substring(1,coordinate.length)); //for each element: 'a6' -> [a][6]					var rowLabels:Array = new Array("a","b","c","d","e","f","g","h","i","j"); //,"k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"					coordinatesArr[i][0] = rowLabels.indexOf(coordinatesArr[i][0])+1; //convert row letter to row number, 'a' = 1, 'b' = 2, etc.    [a][6] -> [1][6]				}			}			return coordinatesArr;		}				private function positionComponent(componentKind:String, componentObj:MovieClip, position:String) {  //  ( 'resistor', [object] , 'a6,b12' )			var xPos:Number;			var yPos:Number;			var x2Pos:Number;			var y2Pos:Number;			var coordinates:Array;			var holeNum:int;			var rowNum:int;			var hole2Num:int;			var row2Num:int;			switch(componentKind) {				case 'resistor':					coordinates = parseCoordinates(position); // string 'a6,b12' -> 2d array [0][0] = 1, [0][1] = 6, [1][0] = 2, [1][1] = 12					holeNum = coordinates[0][1];					rowNum = coordinates[0][0];					xPos = breadboard.getRows()[rowNum][holeNum].x + breadboard.holeSize/2;					yPos = breadboard.getRows()[rowNum][holeNum].y + breadboard.holeSize/2;					componentObj.x = xPos;					componentObj.y = yPos;				break;								case 'wire':					coordinates = parseCoordinates(position); // string 'a6,b12' -> 2d array [0][0] = 1, [0][1] = 6, [1][0] = 2, [1][1] = 12					//trace('coordinates '+coordinates);					var boardSection:Array = new Array();					var getRows:Array = new Array();										for(var i:int=0; i<2; i++){						if(String(coordinates[i][0]).indexOf('pos') != -1) {							boardSection[i] = 'pos';							if(String(coordinates[i][0]) == 'pos1') {								coordinates[i][0] = 1;							} else {								coordinates[i][0] = 2;							}						} else if(String(coordinates[i][0]).indexOf('neg') != -1) {							if(String(coordinates[i][0]) == 'neg1') {								coordinates[i][0] = 1;							} else {								coordinates[i][0] = 2;							}							boardSection[i] = 'neg';						} else {							boardSection[i] = 'main';						}						if(i==0){							holeNum = coordinates[0][1];							rowNum = coordinates[0][0];							//trace('row#  coordinates[0][0] '+coordinates[0][0]);							//trace('hole# coordinates[0][1] '+coordinates[0][1]);													}						if(i==1){							hole2Num = coordinates[1][1];							row2Num = coordinates[1][0];							//trace('row#  coordinates[1][0] '+coordinates[1][0]);							//trace('hole# coordinates[1][1] '+coordinates[1][1]);													}						switch(boardSection[i]) {							case 'pos':								if(i==0){									xPos = breadboard.getPosRows()[rowNum][holeNum].x + breadboard.holeSize/2;									yPos = breadboard.getPosRows()[rowNum][holeNum].y + breadboard.holeSize/2;								}								if(i==1){									x2Pos = breadboard.getPosRows()[row2Num][hole2Num].x + breadboard.holeSize/2;									y2Pos = breadboard.getPosRows()[row2Num][hole2Num].y + breadboard.holeSize/2;								}							break;								case 'neg':								if(i==0){									xPos = breadboard.getNegRows()[rowNum][holeNum].x + breadboard.holeSize/2;									yPos = breadboard.getNegRows()[rowNum][holeNum].y + breadboard.holeSize/2;								}								if(i==1){									x2Pos = breadboard.getNegRows()[row2Num][hole2Num].x + breadboard.holeSize/2;									y2Pos = breadboard.getNegRows()[row2Num][hole2Num].y + breadboard.holeSize/2;								}							break;							case 'main':												trace('main');								if(i==0){									xPos = breadboard.getRows()[rowNum][holeNum].x + breadboard.holeSize/2;									yPos = breadboard.getRows()[rowNum][holeNum].y + breadboard.holeSize/2;								}								if(i==1){									x2Pos = breadboard.getRows()[row2Num][hole2Num].x + breadboard.holeSize/2;									y2Pos = breadboard.getRows()[row2Num][hole2Num].y + breadboard.holeSize/2;								}							break;						}					}					componentObj.x = xPos;					componentObj.y = yPos;					componentObj.dimension(0,0, x2Pos-xPos, y2Pos-yPos);				break;								case 'multimeter':				break;				case 'battery':				break;			}		}										           public function getResistor(id:String) {            return breadboard[id];        }                public function getMultimeter():DmmCentech2 {            return multimeter;        }				public function getBlackProbe():Probe {			return blackProbe;		}		public function getRedProbe():Probe {			return redProbe;		}				public function getProbeVisibility():Boolean {			return blackProbe.visible; // red probe should be the same		}		//visibility can be set from the javascript as follows:		//flash.sendCommand('set_probe_visiblity','true');		//		//or in flash with		//circuit.blackProbe.setVisibility('true');		//circuit.redProbe.setVisibility('true');				public function setProbeVisibility(statStr:String) {			switch((statStr).toLowerCase()) { 		    	case "true":				case "1":				case "yes":				default:				this.blackProbe.visible = true;				this.redProbe.visible = true;				break;				case "false":				case "0":				case "no":				this.blackProbe.visible = false;				this.redProbe.visible = false;			}		}        public function setProbeConnection(probe:Probe):void {  //same as update probe connection, but with a smaller hit area (to ensure that the probe doesn't fall out of the hit area when a component's leads are lifted and lowered)            trace('ENTER Circuit#updateProbeConnection');            var oldConnection:Object = probe.getConnection();            var connection:Object = null;            var ends;                        for (var i = 0; i < components.length; ++i) {                ends = components[i].getEnds();                for (var j = 0; j < 2; ++j) {					if(probe == ends[j].getProbe()) {						ends[j].setProbe(null); //reset lead to not-connected view						ends[j].setBrokenOriginal(); //reset lead to default view						ends[j].setOriginal();  //reset lead to default view					}                    if (ends[j].isBroken()) {                        if (ends[j].inBrokenHotSpot(probe)) {                            connection = ends[j];                            ends[j].setBrokenEngaged();							ends[j].setProbe(probe);                        }                    }                    else {                        if (ends[j].inHotSpot(probe)) {                            connection = ends[j];                            ends[j].setEngaged();							ends[j].setProbe(probe);                        }                    }                }            }                        if (connection !== oldConnection) {                clickSound();                probe.setConnection(connection);				JavaScript.instance().sendEvent('connect', 'probe', probe.getId(), connection.getLocation());                if(connection != null) {					connection.calcProbeShift();				} else {					JavaScript.instance().sendEvent('disconnect', 'probe', probe.getId(), oldConnection.getLocation());				}			}        }        public function setResistorEndColors(probe:Probe):void {            //trace('ENTER Circuit#updateResistorEndColor');			            var ends;            for (var i = 0; i < components.length; ++i) {                ends = components[i].getEnds();                for (var j = 0; j < 2; ++j) {                    if (ends[j].isBroken()) {                        if (ends[j].inBrokenHotSpot(probe)) {                            if (ends[j].getBrokenState() !== Lead.ROLL_OVER) {                                ends[j].setBrokenRollOver();								ends[j].setProbe(probe); //if connected, set probe								//probe.setConnection(ends[j]);//set probe to resistor                            }                        }                        else {                            if (!probeConnected(ends[j]) && ends[j].getBrokenState() !== Lead.ORIGINAL) {                                ends[j].setBrokenOriginal();								ends[j].setProbe(null); //set resistor to no-probe								//probe.setConnection(ends[j]);//set probe to null                            }                        }                    }                    else {                        if (ends[j].inHotSpot(probe)) {                            if (ends[j].getState() !== Lead.ROLL_OVER) {                                ends[j].setRollOver();								ends[j].setProbe(probe); //if connected, set probe								//probe.setConnection(ends[j]);//set probe to resistor                            }                        }                        else {                            if (!probeConnected(ends[j]) && ends[j].getState() !== Lead.ORIGINAL) {                                ends[j].setOriginal();								ends[j].setProbe(null); //set resistor to no-probe								//probe.setConnection(ends[j]);//set probe to no resistor                            }                        }                    }                }            }        }        		public function putProbeOnTop(clickedProbe:Probe):void {			if(redProbe==clickedProbe) {				if(breadboard.getChildIndex(clickedProbe) < breadboard.getChildIndex(blackProbe)) {					breadboard.swapChildren(clickedProbe,blackProbe);				}			} else {				if(breadboard.getChildIndex(clickedProbe) < breadboard.getChildIndex(redProbe)) {					breadboard.swapChildren(clickedProbe,redProbe);				}			}		}		        private function probeConnected(end:Lead):Boolean {            return redProbe.getConnection() == end || blackProbe.getConnection() == end;        }        private function clickSound():void {            sndClickIt=new clickit3();            sndClickItChannel=sndClickIt.play();             transform1.volume=.75;            sndClickItChannel.soundTransform=transform1;        }	}}